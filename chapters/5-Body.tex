\chapter{State-of-the-art}


\chapter{Theoretical Foundation}
\thispagestyle{pagestyle}

\section{Real-time systems}
The main goal for real-time systems is to provide predictable and responsive behaviour, while  \enquote{maintaining reliability as a priority over sheer performance \cite{Hagens2023}}. Another important observation regarding real-time systems is about the correctness of the system which \enquote{ depends not only on the logical result of the computation, but also on the time at which the results are produced \cite{springKernel}}. Thus, real-time systems are classified by deadline, and real-time tasks can be separated into three main categories:
\begin{enumerate}[]
	\item \textbf{Soft:} the results generated after its deadline are still useful to the system, but lead to performance
	degradation. Typical application ares are communication systems such has voice over IP or \enquote{comfort electronics \cite{ecker2009hardware}} such as body electronics in cars.
	
	\item \textbf{Firm:} production of results after its end time has no use for the system, but does not inflict damage. Weather forecast or stock exchange order decision are typical application areas. 
	
	\item \textbf{Hard:} when results are obtained after the specified time limit, the control unit faces a doomsday scenario. \cite{Hagens2023} Common applications are aerospace industry, defense and military, healthcare devices and many more. Examples from the aerospace industry include navigation, autopilot and stability control. For defense and military a bright illustration is the real-time computation of trajectory adjustments for missiles. Medical devices such as implantable pacemakers and defibrillators must deliver electrical pulses to the heart at precise intervals to maintain heartbeat's rhythm. \cite{ibmRTOS2026}

\end{enumerate}

A great analogy of how a real-time system functions in regards to its environment: \enquote{<<Real-time>> means that the IT system is no longer controlling its own time domain. Now it is the progress of time of the environment which dictates
how time has to progress inside the system \cite{ecker2009hardware}.} 

\section{Real-time operating systems}
Basic support for scheduling, handling resources, synchronization, communication, precise timing and input/output is offered by real-time operating systems (RTOSs). Moreover, real-time operating systems prioritize accuracy, certainty and incorporate functions that support time constraints. \cite{stankovic2004realrtos} 

Different RTOSs are designed to meet specific needs in a plethora of domains. To mention a few of them, which ensure predictability, high performance and reliability:

\begin{itemize}
	\item \textbf{VxWorks:} used in aerospace, defense and industrial automation. Well-known for \enquote{scalability, security and safety features \cite{ibmRTOS2026}.}
	
	\item \textbf{QNX:} modular and POSIX-compilant RTOS is preferred in the medical and automotive sector (infotainment systems) for error tolerance and reliability. As of short notice, the \textbf{Blackbery 10} OS is based on QNX. \cite{wikipediaQNX}
	
	\item \textbf{FreeRTOS:} An open-source RTOS, property of AWS is a aimed for high-performance embedded systems, IoT devices (smart CCTV camera) and even consumer electronics \enquote{emphasizing simplicity and efficiency \cite{ibmRTOS2026}}.
\end{itemize}

\section{Scheduling algorithm}

  Richard Barry and The FreeRTOS Team mentions in the manual a concise description for what a scheduling algorithm depicts, \enquote{The scheduling algorithm is the software routine that decides which Ready state task to transition into the Running state \cite{mastering}}. Let us denote a set of n generic tasks \begin{math} T = \left\{ t_1, t_2, \ldots, t_n \right\} \end{math}, a set of m processors \begin{math} P = \left\{ p_1, p_2, \ldots, p_m \right\} \end{math} and a set of k resources \begin{math} R = \left\{ r_1, r_2, \ldots, r_k \right\} \end{math}. In reality, the aim of real-time scheduling is to assign processors from P and resources from R to tasks from T in such a manner that all task instances are concluded within the limits imposed \cite{ecker2009hardware}. There are 2 categories of scheduling algorithms, either preemptive or non preemptive. With preemptive scheduling, a task in the \textit{Running} state can be interrupted at nay time and resumed later. Each interruption causes a postponement in the task's execution, which the real-time operating system must manage to ensure the deadline is met. In non preemptive scheduling once a task has started it will run continuously until it finishes or enters the \textit{Blocked} state. The non preemptive approach yield fewer context switches since substituting one task with another is an intense and expensive operation due to many processors locations must to be saved and restored. Nevertheless, non preemptive approaches might seem preferable for real-time scheduling; in practice, the lack of preemption imposes such strict limitations on the planner that predictable real-time scheduling with acceptable utilisation is generally only achievable when preemption is permitted \cite{ecker2009hardware}.
  
  
\section{Task life cycle}
\begin{figure}[H]
	\includegraphics[width=0.4\textwidth]{images/state_transition.png}
	\caption{Task state machine \cite{mastering}}
	\label{fig:myfig}
\end{figure}

In the FreeRTOS kernel architecture the task concept is defined as an independent execution thread. In other words,
a task is a program with a small footprint that operates in an infinite loop. As a human life, the life cycle of a task
includes instantiation, transitions of the state and inevitable termination. Tasks are viable only if events drive them. For a task to be an event-driven, it must be triggered by an event in order to perform work. The highest priority task that can be executed is invariably picked by the scheduling algorithm. Whether a high-priority task is waiting for an event and is impossible to run, a lower-priority task will take its place instead. As a result, event-driven tasks may be attributed various priority indexes eliminating the risk of task starvation for higher-priority tasks.
\cite{mastering} 


\section{Cooperative Scheduling}

Cooperative scheduling depicts a planning algorithm where the FreeRTOS scheduler only transitions a \textit{Ready} state task into the Running state when the currently executing task either enters the \textit{Blocked} state, or the \textit{Running} state task yields overtly. Due to the fact that the cooperative scheduler does not inevitably disrupt tasks at specific intervals, the kernel never preempts tasks at tick interrupts. Moreover, a context switch eventuates if and only if a task calls \textit{taskYIELD()}, or enters \textit{Blocked} states, or an application defined interrupt explicitly acts as a context switch. If there exists a higher-priority task in \textit{Ready} state, while a lower-priority tasks is executing, the context switcher is not going to perform a switch immediately. \cite{mastering} \newline
Cooperative scheduling is enabled by setting \textbf{configUSE\_PREEMPTION 0} and functions with any time slicing value for the configuration constant \textbf{configUSE\_TIME\_SLICING}.

\section{Preemptive scheduling}
In FreeRTOS, preemptive scheduling is a scheduling algorithm in which the kernel always ensures that the highest priority task being in the \textit{Ready} state is executing. Under this particular model, the scheduler instantly preempts a lower-priority task if a higher-priority task is in \textit{Ready} state. The action of preempting an executing task may take place at any time, not only during RTOS tick interruptions. \cite{mastering}


\section{Cooperative vs Preemptive Scheduling}
\begin{table}[H]
	\caption{Scheduling algorithms comparison}
	\label{table:table1}
	\begin{tabular}{ |p{5cm}|p{4cm}|p{4cm}| }
		\hline
		Feature & Cooperative & Preemptive \\
		\hline
		configUSE\_PREEMPTION &  Set to \textbf{0} & Set to \textbf{1}\\
		\hline
		Starvation risk & High & Low \\
		\hline
		Time slicing &  Not supported  & Supported  \\
		\hline
		Context Switch Triggers & calling taskYIELD() or entering \textit{Blocked} state& I/O events and tick interrupts and yields\\
		\hline
		Task Preemption & Tasks are never preempted by the kernel since the Running task has exclusive control until it gives it up & Tasks can be voluntarily removed from the state of execution any time by the scheduler \\
		\hline
		Resource management & Simplified, since the application writer can ensure a task does not yield until a resource is in a consistent state  & More complex, because tasks can be preempted when a shared resource is in inconsistent state, leading to data corruption \\
		\hline
		Responsiveness & Lower; high-priority tasks must wait for the current task to block or call taskYIELD() & High, the planner starts a high priority task immediately after becoming ready \\ 
		\hline
	\end{tabular}
\end{table}

\section{Kernel version migration}
The initial project ran on version 10.4.4, but we have migrated to current latest version being 11.1.0. The impactful change
in project structure is that the latest contains a new file \textbf{FreeRTOS-Kernel/portable/GCC/ARM\_CM0/portasm.c} which needs to be introduced in the CMake's sight as an additional library. This file handles MPU configuration, which is not
supported for the Raspberry Pi Pico.


\chapter{Proposed solution and Development Methodology}

\chapter{Implementation}

\chapter{Conclusions, Contributions and Future Work}
